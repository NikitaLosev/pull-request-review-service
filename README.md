# Backend Trainee Assignment (Autumn 2025) - PR Reviewer Assignment Service

Это решение тестового задания для стажёра Авито в Backend. Сервис автоматически назначает ревьюеров на Pull Request`ы (PR), управляет командами и активностью пользователей в соответствии с предоставленными требованиями и спецификацией OpenAPI.

## Стек

*   **Язык:** Go (1.23)
*   **База данных:** PostgreSQL
*   **Библиотеки:** Chi (HTTP Router), pgx/v5 (PostgreSQL Driver), golang-migrate (Миграции)
*   **Развертывание:** Docker & Docker Compose

## Как запустить

Сервис соответствует требованию запуска через `docker-compose up`, включая автоматическое применение миграций.

### Требования

*   Docker
*   Docker Compose

### Запуск

1.  Убедитесь, что все файлы решения находятся в одной директории.
2.  Скопируйте `.env.example` в `.env` и при необходимости скорректируйте значения (по умолчанию сервис слушает `8080`, БД доступна по `postgres://review_user:changeme@db:5432/review_db`).
3.  Запустите сервисы:

    ```bash
    docker-compose up --build
    ```

Сервис будет доступен по адресу `http://localhost:8080`.

### Тесты и качество

* Юнит/интеграционные тесты: `go test ./...`
  * Сервисный слой — in-memory репозиторий.
  * HTTP-интеграция — `httptest`.
  * Интеграция с Postgres — через Docker (dockertest). Если Docker недоступен, тест пропускается.
* Линтер (golangci-lint в Docker, конфиг в `.golangci.yml`): `make lint` (образ `golangci/golangci-lint:v1.62.2`)
* Общие цели: `make test`, `make build`, `make docker-up`, `make docker-down`

### Мониторинг и документация

* `GET /metrics` — метрики Prometheus (содержат счётчики/гистограммы HTTP).
* Swagger UI: контейнер `docs` на `${DOCS_PORT:-8081}` (по умолчанию `http://localhost:8081`) читает локальный `openapi.yml`.
* Prometheus/Grafana: контейнеры `prometheus` (`${PROM_PORT:-9090}`) и `grafana` (`${GRAFANA_PORT:-3000}`) уже сконфигурированы, Prometheus собирает метрики с `api:8080`.
* Открыть Swagger: `http://localhost:8081/?url=/openapi.yml` после `docker-compose up`.

### Полезные эндпоинты

* `GET /health` — быстрый health check контейнера.
* Остальные ручки соответствуют `openapi.yml` (поддерживается как `old_user_id`, так и `old_reviewer_id` для переназначения).
* `GET /metrics` — метрики Prometheus.
* Swagger UI: поднимается отдельным контейнером `docs` на `${DOCS_PORT:-8081}` (по умолчанию `http://localhost:8081`).
* Prometheus/Grafana: запускаются контейнерами `prometheus` (`${PROM_PORT:-9090}`) и `grafana` (`${GRAFANA_PORT:-3000}`) с готовым сбором метрик с `api:8080`.

### Нагрузочные тесты

В репозитории есть пример `k6`-скрипта `loadtest.js` (создание/merge PR с уникальными ID + health):

```bash
make loadtest                       # TARGET=... TEAM=... TEST_RUN_ID=... при необходимости
```

Требуемые пороги заданы в скрипте: p95 < 300мс, успешность 99.9%.

### Допущения и заметки

* Базовая метрика — экспонирование стандартных Go/Prometheus метрик и HTTP метрик (`/metrics`). Этого достаточно для подключения Prometheus/Grafana из docker-compose.
* E2E/интеграционные тесты покрывают основной happy-path и доменные ограничения (идемпотентность merge, валидация входных данных, повторное назначение на merged PR). Дополнительно сервисный слой тестируется отдельно на чистом in-memory репозитории.

## Ключевые особенности и принятые решения

### Дизайн Базы Данных

*   **Хранение ревьюеров:** Ревьюеры хранятся в виде массива `TEXT[]` (`assigned_reviewers`) в таблице `pull_requests`. Это эффективно, так как количество ревьюеров ограничено (максимум 2).
*   **Индексация:** Используется **GIN индекс** для `assigned_reviewers`, что позволяет эффективно выполнять запросы на поиск PR по ревьюеру (эндпоинт `/users/getReview`).
*   **Логика Назначения:** Выбор случайных ревьюеров происходит на уровне базы данных с помощью `ORDER BY RANDOM() LIMIT 2`.

### Консистентность и Конкурентность

*   **Транзакции:** Все операции, изменяющие данные, обернуты в транзакции базы данных, реализованные на уровне репозитория.
*   **Блокировка (Переназначение):** Операция `/pullRequest/reassign` использует цикл Read-Modify-Write. Для предотвращения состояний гонки используется `SELECT ... FOR UPDATE` внутри транзакции для явной блокировки строки PR до завершения обновления.
*   **Идемпотентный Merge:** Операция `/pullRequest/merge` идемпотентна. Это достигается с помощью SQL функции `COALESCE(merged_at, NOW())` при обновлении, что гарантирует установку времени слияния только при первом вызове.

### Миграции

*   Миграции управляются `golang-migrate`. В `docker-compose.yml` настроен отдельный контейнер `migrate`, который запускается и завершается до старта основного приложения, гарантируя актуальность схемы БД.

### Соответствие OpenAPI

*   API строго следует спецификации. В спецификации схема требует `old_user_id` для переназначения, а пример использует `old_reviewer_id`. Реализация следует **определению схемы** и ожидает `old_user_id`.
